title: Declaration
prototype: false
properties:
  data:
    type: "[`Uint8Array`]()"
    description: |
      The data that has been signed.
  signatures:
    type: "[`Array`]() of [`Uint8Array`]()"
    description: |
      List of signatures. Each is generated by signing `data` with a given signatory's private key.
  signatories:
    type: "[`Array`]() of [`Uint8Array`]()"
    description: |
      List of public keys. Each matches the corresponding signature in `signatures`.  These keys identify the signatories who used their private key to sign `data` and can be used to validate that matching signature.

methods:
  isType:
    signature:
      - inputs: [ value ]
        output: is-declaration
    variables:
      value:
        type: Value
        description: |
          A value to be tested.
      is-declaration:
        type: "[`Boolean`]()"
        description: |
          `true` if `value` is an instance of [`Declaration`](), `false` otherwise.
    prose: |
      Type check method to determine if the input `value` is an instance of [`Declaration`]().  Returns `true` or `false`.

      A [`Declaration`]() organizies the signatures and signatories on a piece of data to make it easy to transport and verify its integrity.

  from:
    signature:
      - inputs: [ format, data ]
        output: declaration
    variables:
      to:
        type: "[`String`]()"
        description: |
          name that specifies the input format.
      data:
        type: "[`String`]() | [`Uint8Array`]() | [`Buffer`]() | [`Object`]()"
        description: |
          A representation of the data of a declaration.
      declaration:
        type: "[`Declaration`]()"
        description: |
          The declaration in an encoded form for transport or storage.
    prose: |
      Outputs this wrapper's value (stored as [`Uint8Array`]()) as the form specified in `format`.

      #### Supported Types
      - `bytes`: A byte array, specifically [`Uint8Array`]() or its equivalent in Node.js [`Buffer`]()
      - `utf8`: A [`String`]() with [UTF-8 encoding]()
      - `base64`: A [`String`]() with [Base64 encoding]()
      - `safe-base64`: A [`String`]() with [URL-Safe Base64 encoding]()
      - `object`: An [`Object`]

      Specifying an unsupported conversion throws.

  to:
    signature:
      - inputs: [ format ]
        output: encoded-declaration
    variables:
      to:
        type: "[`String`]"
        description: |
          name that specifies the output encoding.
      encoded-declaration:
        type: "[`String`]() | [`Uint8Array`]()"
        description: |
          The declaration in an encoded form for transport or storage.
    prose: |
      Converts this wrapper's value (stored as [`Uint8Array`]()) into another form for transport or storage, as specified by `to`.

      #### Supported Types
      - `utf8`: A [`String`]() with [UTF-8 encoding]()
      - `base64`: A [`String`]() with [Base64 encoding]()
      - `safe-base64`: A [`String`]() with [URL-Safe Base64 encoding]()

      Specifying an unsupported conversion throws.


prose: |
  The return value for [`sign`]().

  Declarations are self-contained entities that have everything you need to check their integrity. When passed to [`verify`](), that function matches all the `signatories` to the `signatures` and validates the [digital signature]().

  You may serialize a `Declaration` using [`convert`]().

  While a Declaration can be verified to be internally self-consistent, it is up to you to verify the public keys belong to whoever claims to have sent the data.

title: convert
signature:
  - inputs: [ hint, input ]
    output: [ output ]

variables:
  hint:
    type: "[`Object`]()"
    description: |
      Describes the conversion to be applied to _input_. Contains the properties `from` and `to`.
  input:
    type: "[`Uint8Array`]() | [`Buffer`]() | [`String`]()"
    description: |
      The value to be converted.
  output:
    type: "[`Uint8Array`]() | [`Buffer`]() | [`String`]()"
    description: |
      The result of the conversion.

prose: |
  A utility function to manage data format conversion between a variety of targets.

  A conversion is specified by `hint`'s fields, `from` and `to`.  These identify the current and target encoding of `input`, respectively.

  Normally, you should not need to directly use this function because Panda-Confidential provides typed containers for the input and output of the main generics ([`encrypt`](), [`decrypt`](), [`sign`](), and [`verify`]()).  Those containers ([`Plaintext`](), [`Envelope`](), and [`Declaration`]()) have methods to manage data encoding, and use `convert` internally, providing a standard interface.

  #### Supported Formats
  - `bytes`: A byte array, specifically [`Uint8Array`]() or its equivalent in Node.js [`Buffer`]()
  - `utf8`: A [`String`]() with [UTF-8 encoding]()
  - `base64`: A [`String`]() with [Base64 encoding]()
  - `safe-base64`: A [`String`]() with [URL-Safe Base64 encoding]()

  #### Errors
  `convert` is meant to provide safe and correct format conversion for your data.  There are a number of checks in place that will throw errors if they fail:
  - Specifying an unsupported conversion
  - Failing to specify either `from` or `to`
  - Specifying the same value for `from` and `to`
  - Specifying a value for `from` that conflicts with the type of `input`. ex, specifying `bytes` when the input is a string


examples:
  - title: String Conversion
    content: |
      ```coffeescript
      import assert from "assert"
      import {confidential} from "panda-confidential"
      {convert} = confidential()

      do ->
        assert.equal "Hello, World!",
          convert from: "base64", to: "utf8", "SGVsbG8sIFdvcmxkIQ=="

        assert.equal (Buffer.from "Hello, World!"),
          convert from: "utf8", to: "bytes" , "Hello, World!"

        assert.equal "Hello, World!",
          convert from: "bytes", to: "utf8", Buffer.from "Hello, World!"
      ```

  - title: Formatting Data for the API
    content: |
      The Panda-Confidential generics, ([`encrypt`](), [`decrypt`](), [`sign`](), and [`verify`]()) are purposefully agnostic to the content they process, be it text or binary media.  The API always operates on byte arrays, requiring you convert inputs into bytes and then dealing with byte array outputs.

      Normally, you will not need to use `convert` directly because Panda-Confidential provides type containers with builtin formatting helper methods.  Their interfaces are standardized by using `convert` internally, so you provide each with explicit formatting instructions via `hint`.

      Here is an example that uses these containers and their formatting helpers. Please see those class references for more information.


      ```coffeescript
      import assert from "assert"
      import {confidential} from "panda-confidential"
      {SharedKey, Plaintext, encrypt, Envelope, decrypt} = confidential()
      import {keyLookup} from "my-library"
      do ->
        # First, Alice creates a SharedKey for asymmetric encryption..
        alice = keyLookup "Alice/private"
        bob = keyLookup "Bob/public"
        fromAliceToBob = SharedKey.create alice, bob

        # Use the Plaintext static method to turn the message into a byte array
        plaintext = Plaintext.from "utf8", "Hello, Bob!"
        envelope = await encrypt fromAliceToBob, plaintext

        # Use the Envelope instance method `to` to serialize.
        send "Bob", envelope.to "base64"



        # Later, with Bob on the recieving end....
        alice = keyLookup "Alice/public"
        bob = keyLookup "Bob/private"
        toBobFromAlice = SharedKey.create alice, bob
        serialized = receive "Bob"

        # Use the Envelope static method `from` to hydrate a new Envelope
        envelope = Envelope.from "base64", serialized
        plaintext = await decrypt toBobFromAlice, envelope

        # Use the Plaintext instance method to encode the resulting plaintext
        assert.equal (plaintext.to "utf8"), "Hello, Bob!"
      ```
